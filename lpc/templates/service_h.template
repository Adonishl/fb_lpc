// automaticly generated by {{protocol_file_name}}, don't modify
#pragma once
{% for path in generated_fb_headers %}
#include "{{path}}"
{% endfor %}
#include "lpc/client_base.h"
#include "lpc/message.h"
#include "lpc/server_base.h"
#include <memory>
#include <iostream>

namespace {{namespace}} {

class {{client_name}} : public lpc::ClientBase {
public:
  {{client_name}}(unsigned int input_buffer_size,
                      unsigned int output_buffer_size)
      : lpc::ClientBase(input_buffer_size, output_buffer_size) {}
  {% for service in service_list %}
  void {{service.name}}(const lpc::Message<{{service.input_type}}> *{{service.input_name}},
                 lpc::Message<{{service.output_type}}> &{{service.output_name}}) {
    Call({{service.idx}}, input, output);
  }
  {% endfor %}
};

// Impl only declare the member function here, user must impl them before
// compile
class {{server_name}}Impl {
public:
  {% for service in service_list %}
  void {{service.name}}(const lpc::Message<{{service.input_type}}> *{{service.input_name}},
                 lpc::Message<{{service.output_type}}> &{{service.output_name}});
  {% endfor %}
};

class {{server_name}} : public lpc::ServerBase {
public:
  {{server_name}}(unsigned int input_buffer_size,
                      unsigned int output_buffer_size)
      : lpc::ServerBase(input_buffer_size, output_buffer_size) {
    impl_ = std::unique_ptr<{{server_name}}Impl>();
  }
  // Serve() will run in a while-loop, which keep listen from client
  void Serve() {
    std::cout << "serving start..." << std::endl;
    while (true) {
      unsigned int func_id = 0;
      unsigned int data_size = 0;
      auto data_ptr = this->GetInput(func_id, data_size);
      switch (func_id) {
      {% for service in service_list %}
      case {{service.idx}}: {
        auto input_msg =
            lpc::Message<{{service.input_type}}>(data_ptr, data_size);
        lpc::Message<{{service.output_type}}> output_msg;
        impl_->{{service.name}}(&input_msg, output_msg);
        this->SendOutput(output_msg.data(), output_msg.size());
        break;
      }
      {% endfor %}
      default:
        std::cerr << "func_id: " << func_id << "is not supported" << std::endl;
      }
    }
  }

private:
  std::unique_ptr<{{server_name}}Impl> impl_;
};

} // namespace {{namespace}}